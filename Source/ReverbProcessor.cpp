/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "ReverbProcessor.h"
#include "ReverbEditor.h"

const float defaultRoomSize = 0.5f;
const float defaultDamping = 0.5f;
const float defaultWetLevel = 0.33f;
const float defaultDryLevel = 0.4f;
const float defaultWidth = 1.0f;

//==============================================================================
ReverbProcessor::ReverbProcessor() : parameters(*this, nullptr)
{
	parameters.createAndAddParameter("roomSize",       // parameter ID
		"Room Size",       // parameter name
		String(),     // parameter label (suffix)
		NormalisableRange<float>(0.0f, 1.0f),    // range
		defaultRoomSize,         // default value
		nullptr,
		nullptr);

	parameters.createAndAddParameter("damping",       // parameter ID
		"Damping",       // parameter name
		String(),     // parameter label (suffix)
		NormalisableRange<float>(0.0f, 1.0f),    // range
		defaultDamping,         // default value
		nullptr,
		nullptr);

	parameters.createAndAddParameter("wet",       // parameter ID
		"Wet",       // parameter name
		String(),     // parameter label (suffix)
		NormalisableRange<float>(0.0f, 1.0f),    // range
		defaultWetLevel,         // default value
		nullptr,
		nullptr);

	parameters.createAndAddParameter("dry",       // parameter ID
		"Dry",       // parameter name
		String(),     // parameter label (suffix)
		NormalisableRange<float>(0.0f, 1.0f),    // range
		defaultDryLevel,         // default value
		nullptr,
		nullptr);

	parameters.createAndAddParameter("width",       // parameter ID
		"Width",       // parameter name
		String(),     // parameter label (suffix)
		NormalisableRange<float>(0.0f, 1.0f),    // range
		defaultWidth,         // default value
		nullptr,
		nullptr);

	parameters.state = ValueTree(Identifier("Reverb"));
}

ReverbProcessor::~ReverbProcessor()
{
}

//==============================================================================
const String ReverbProcessor::getName() const
{
    return JucePlugin_Name;
}

const String ReverbProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ReverbProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ReverbProcessor::isInputChannelStereoPair (int index) const
{
    ignoreUnused (index);
    return true;
}

bool ReverbProcessor::isOutputChannelStereoPair (int index) const
{
    ignoreUnused (index);
    return true;
}

bool ReverbProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool ReverbProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool ReverbProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double ReverbProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int ReverbProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int ReverbProcessor::getCurrentProgram()
{
    return 0;
}

void ReverbProcessor::setCurrentProgram (int index)
{
    ignoreUnused (index);
}

const String ReverbProcessor::getProgramName (int index)
{
    ignoreUnused (index);
    return String();
}

void ReverbProcessor::changeProgramName (int index, const String& newName)
{
    ignoreUnused (index, newName);
}

//==============================================================================
void ReverbProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    ignoreUnused (samplesPerBlock);

    reverb = new Reverb;
    reverb->setSampleRate (sampleRate);
    reverb->reset();
}

void ReverbProcessor::releaseResources()
{
    reverb = nullptr;
}

void ReverbProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    ignoreUnused (midiMessages);

    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    Reverb::Parameters p;

	p.roomSize = *parameters.getRawParameterValue("roomSize");
	p.damping = *parameters.getRawParameterValue("damping");
	p.wetLevel = *parameters.getRawParameterValue("wet");
	p.dryLevel = *parameters.getRawParameterValue("dry");
	p.width = *parameters.getRawParameterValue("width");
    p.freezeMode = 0.0f;

    reverb->setParameters (p);

    if (getNumInputChannels() > 0)
    {
        if (getNumInputChannels() == 1)
            reverb->processMono (buffer.getWritePointer (0), buffer.getNumSamples());
        else 
            reverb->processStereo (buffer.getWritePointer (0), buffer.getWritePointer (1), buffer.getNumSamples());
    }   
}

//==============================================================================
bool ReverbProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* ReverbProcessor::createEditor()
{
    return new ReverbEditor (*this, parameters);
}

//==============================================================================
void ReverbProcessor::getStateInformation (MemoryBlock& destData)
{
	ScopedPointer<XmlElement> xml(parameters.state.createXml());
	copyXmlToBinary(*xml, destData);
}

void ReverbProcessor::setStateInformation (const void* data, int sizeInBytes)
{
	ScopedPointer<XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));
	if (xmlState != nullptr)
		if (xmlState->hasTagName(parameters.state.getType()))
			parameters.state = ValueTree::fromXml(*xmlState);
}

//==============================================================================
void ReverbProcessor::parameterChange (AudioProcessorParameter* param, float newValue)
{
    // do something with this
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ReverbProcessor();
}
